\documentclass[a4paper]{article}

\setlength{\parskip}{2mm}
\newcommand{\tab}{~ \qquad}
\input{Macros}
\usepackage{caratula} % Version modificada para usar las macros de algo1 de ~> https://github.com/bcardiff/dc-tex
\usepackage{graphicx}
\usepackage{booktabs}
\usepackage{amsmath}
\usepackage{amssymb}

\begin{document}

\titulo{Optimización de Rendimiento en Arquitecturas de Computadoras}
\subtitulo{Análisis Comparativo de Técnicas de Aceleración}
\fecha{30 de Agosto de 2025}
\materia{Organización del Computador II}
\grupo{Grupo 1}

\integrante{Polonuer, Joaquin}{1612/21}{jtpolonuer@gmail.com}

\maketitle

\tableofcontents
\newpage

\section{Introducción}

\subsection{La Ecuación de Onda}

La ecuación de onda representa uno de los fenómenos físicos más fundamentales en la naturaleza, describiendo la propagación de perturbaciones en medios continuos. Desde ondas sonoras y electromagnéticas hasta vibraciones mecánicas, este modelo matemático encuentra aplicación en campos tan diversos como la acústica, la óptica, la sismología y la ingeniería estructural.

\subsubsection{Ecuación de Onda en Una Dimensión}

La ecuación de onda unidimensional se expresa como:

\begin{equation}
\frac{\partial^2 u}{\partial t^2} = c^2 \frac{\partial^2 u}{\partial x^2}
\end{equation}

donde $u(x,t)$ representa el desplazamiento de la onda en el punto $x$ y tiempo $t$, y $c$ es la velocidad de propagación característica del medio. Esta ecuación diferencial parcial de segundo orden describe fenómenos como:

\begin{itemize}
\item Vibraciones de cuerdas tensadas
\item Propagación de ondas sonoras en tubos
\item Ondas electromagnéticas en líneas de transmisión
\end{itemize}

\subsubsection{Ecuación de Onda en Dos Dimensiones}

La extensión a dos dimensiones espaciales resulta en:

\begin{equation}
\frac{\partial^2 u}{\partial t^2} = c^2 \left(\frac{\partial^2 u}{\partial x^2} + \frac{\partial^2 u}{\partial y^2}\right) = c^2 \nabla^2 u
\end{equation}

Esta formulación bidimensional modela fenómenos como:

\begin{itemize}
\item Vibraciones de membranas (tambores, diafragmas)
\item Ondas superficiales en líquidos
\item Propagación de ondas sísmicas en planos
\item Ondas electromagnéticas en cavidades rectangulares
\end{itemize}

La solución numérica de estas ecuaciones mediante métodos de diferencias finitas o elementos finitos requiere algoritmos computacionalmente intensivos que se benefician significativamente de técnicas de optimización.

\subsection{La Transformada de Fourier}

La Transformada de Fourier constituye una herramienta matemática fundamental para el análisis de fenómenos ondulatorios, permitiendo descomponer señales complejas en sus componentes frecuenciales básicas. Esta transformación resulta especialmente poderosa en el contexto de la resolución de ecuaciones diferenciales parciales.

La Transformada de Fourier continua de una función $f(x)$ se define como:

\begin{equation}
F(\omega) = \int_{-\infty}^{\infty} f(x) e^{-j\omega x} dx
\end{equation}

y su transformada inversa:

\begin{equation}
f(x) = \frac{1}{2\pi} \int_{-\infty}^{\infty} F(\omega) e^{j\omega x} d\omega
\end{equation}

Esta representación en el dominio frecuencial revela propiedades fundamentales de las señales y simplifica considerablemente el análisis de sistemas lineales.

\subsection{Resolución de la Ecuación de Onda mediante la Transformada de Fourier}

La aplicación de la Transformada de Fourier a la ecuación de onda trasforma el problema diferencial en uno algebraico, facilitando significativamente su resolución. Considerando la ecuación de onda unidimensional con condiciones iniciales:

\begin{equation}
\frac{\partial^2 u}{\partial t^2} = c^2 \frac{\partial^2 u}{\partial x^2}
\end{equation}

Al aplicar la Transformada de Fourier espacial, obtenemos:

\begin{equation}
\frac{\partial^2 \hat{u}}{\partial t^2} = -c^2 \omega^2 \hat{u}
\end{equation}

donde $\hat{u}(\omega, t)$ es la transformada de Fourier de $u(x,t)$ respecto a $x$. Esta ecuación diferencial ordinaria en el tiempo tiene solución analítica conocida:

\begin{equation}
\hat{u}(\omega, t) = A(\omega) e^{jc\omega t} + B(\omega) e^{-jc\omega t}
\end{equation}

Los coeficientes $A(\omega)$ y $B(\omega)$ se determinan a partir de las condiciones iniciales, y la solución final se obtiene aplicando la transformada inversa de Fourier.

Esta metodología demuestra la potencia computacional de la Transformada de Fourier, convirtiendo operaciones de derivación en multiplicaciones algebraicas simples. En implementaciones numéricas, la eficiencia de algoritmos FFT (Fast Fourier Transform) resulta crítica para la viabilidad computacional de estos métodos espectrales.

El marco teórico se fundamenta en los principios de arquitectura de computadoras y optimización de código aplicados específicamente a algoritmos de procesamiento de señales. Las aplicaciones similares en el campo científico e industrial incluyen bibliotecas de álgebra lineal optimizadas como BLAS \cite{lawson1979basic}, implementaciones optimizadas de FFT como FFTW \cite{frigo2005design}, frameworks de computación paralela como OpenMP \cite{dagum1998openmp}, y compiladores optimizantes que emplean técnicas avanzadas de análisis estático \cite{muchnick1997advanced}.

\subsection{Transformada Discreta de Fourier}

Para implementaciones computacionales, la Transformada de Fourier continua debe discretizarse. La Transformada Discreta de Fourier (DFT) de una secuencia finita $x[n]$ de $N$ elementos se define como:

\begin{equation}
X[k] = \sum_{n=0}^{N-1} x[n] e^{-j2\pi kn/N}, \quad k = 0, 1, \ldots, N-1
\end{equation}

donde $X[k]$ representa los coeficientes espectrales discretos. La transformada inversa se expresa como:

\begin{equation}
x[n] = \frac{1}{N} \sum_{k=0}^{N-1} X[k] e^{j2\pi kn/N}, \quad n = 0, 1, \ldots, N-1
\end{equation}

La implementación directa de la DFT requiere $O(N^2)$ operaciones complejas, lo que resulta computacionalmente prohibitivo para secuencias largas. Esta limitación motivó el desarrollo del algoritmo Fast Fourier Transform.

\subsection{Transformada Rápida de Fourier (Cooley-Tukey)}

El algoritmo FFT, desarrollado por Cooley y Tukey en 1965, reduce la complejidad computacional de $O(N^2)$ a $O(N \log N)$ mediante la estrategia de divide y vencerás. Para $N = 2^m$, el algoritmo descompone la DFT en DFTs más pequeñas.

El algoritmo DIT (Decimation-in-Time) separa la secuencia de entrada en muestras pares e impares:

\begin{equation}
X[k] = \sum_{n \text{ par}} x[n] e^{-j2\pi kn/N} + \sum_{n \text{ impar}} x[n] e^{-j2\pi kn/N}
\end{equation}

Sustituyendo $n = 2r$ para índices pares y $n = 2r+1$ para impares:

\begin{equation}
X[k] = \sum_{r=0}^{N/2-1} x[2r] e^{-j2\pi kr/(N/2)} + e^{-j2\pi k/N} \sum_{r=0}^{N/2-1} x[2r+1] e^{-j2\pi kr/(N/2)}
\end{equation}

Definiendo:
\begin{align}
X_{\text{par}}[k] &= \sum_{r=0}^{N/2-1} x[2r] e^{-j2\pi kr/(N/2)} \\
X_{\text{impar}}[k] &= \sum_{r=0}^{N/2-1} x[2r+1] e^{-j2\pi kr/(N/2)}
\end{align}

La ecuación se simplifica a:

\begin{equation}
X[k] = X_{\text{par}}[k] + W_N^k \cdot X_{\text{impar}}[k]
\end{equation}

donde $W_N^k = e^{-j2\pi k/N}$ es el factor de giro (twiddle factor).

Aprovechando la periodicidad $X_{\text{par}}[k + N/2] = X_{\text{par}}[k]$ y la simetría $W_N^{k+N/2} = -W_N^k$:

\begin{align}
X[k] &= X_{\text{par}}[k] + W_N^k \cdot X_{\text{impar}}[k] \\
X[k + N/2] &= X_{\text{par}}[k] - W_N^k \cdot X_{\text{impar}}[k]
\end{align}

Este proceso se aplica recursivamente hasta obtener DFTs de un solo elemento.

\section{Metodología}

Se propone implementar un simulador físico que resuelva la ecuación de onda con los métodos mencionados en la introducción. Se comparan 4 backends diferentes: Python, NumPy, C, y C + ASM (Assembly).

El objetivo es evaluar el rendimiento de cada implementación midiendo la variable \textit{steps per second} (pasos por segundo), que indica cuántos pasos de simulación puede procesar cada backend en un segundo. Esta métrica es fundamental para evaluar la eficiencia computacional de diferentes enfoques de implementación.

\subsection{Python}

Implementación base utilizando Python puro con estructuras de datos nativas. Esta implementación sirve como línea base para comparar el rendimiento de las optimizaciones posteriores.

\begin{verbatim}
def wave_equation_step(grid, dt, dx, c):
    """
    Implementación básica del paso de la ecuación de onda en Python
    """
    rows, cols = len(grid), len(grid[0])
    new_grid = [[0.0 for _ in range(cols)] for _ in range(rows)]
    
    for i in range(1, rows-1):
        for j in range(1, cols-1):
            laplacian = (grid[i+1][j] + grid[i-1][j] + 
                        grid[i][j+1] + grid[i][j-1] - 4*grid[i][j])
            new_grid[i][j] = grid[i][j] + c*c*dt*dt*laplacian/(dx*dx)
    
    return new_grid
\end{verbatim}

\subsection{NumPy}

Implementación optimizada utilizando NumPy como estado del arte para computación científica en Python. Aprovecha las operaciones vectorizadas y bibliotecas optimizadas de álgebra lineal.

\begin{verbatim}
import numpy as np

def wave_equation_step_numpy(grid, dt, dx, c):
    """
    Implementación vectorizada usando NumPy
    """
    laplacian = np.zeros_like(grid)
    laplacian[1:-1, 1:-1] = (grid[2:, 1:-1] + grid[:-2, 1:-1] + 
                            grid[1:-1, 2:] + grid[1:-1, :-2] - 
                            4 * grid[1:-1, 1:-1])
    
    new_grid = grid + c*c*dt*dt*laplacian/(dx*dx)
    return new_grid
\end{verbatim}

\subsection{C}

Implementación en lenguaje C utilizando optimizaciones del compilador para lograr mayor eficiencia en el acceso a memoria y operaciones aritméticas.

\begin{verbatim}
#include <stdio.h>
#include <stdlib.h>

void wave_equation_step_c(double** grid, double** new_grid, 
                         int rows, int cols, double dt, 
                         double dx, double c) {
    double factor = c * c * dt * dt / (dx * dx);
    
    for (int i = 1; i < rows - 1; i++) {
        for (int j = 1; j < cols - 1; j++) {
            double laplacian = grid[i+1][j] + grid[i-1][j] + 
                              grid[i][j+1] + grid[i][j-1] - 
                              4.0 * grid[i][j];
            new_grid[i][j] = grid[i][j] + factor * laplacian;
        }
    }
}
\end{verbatim}

\subsection{C + ASM}

Implementación híbrida combinando C con rutinas críticas optimizadas en Assembly x86-64, utilizando instrucciones SIMD (SSE/AVX) para procesamiento vectorial.

Código C:
\begin{verbatim}
#include <immintrin.h>

void wave_equation_step_avx(double* grid, double* new_grid,
                                 int rows, int cols, double dt,
                                 double dx, double c) {
    double factor = c * c * dt * dt / (dx * dx);
    
    for (int i = 1; i < rows - 1; i++) {
        wave_step_asm_row(&grid[i*cols], &new_grid[i*cols], 
                         cols, factor);
    }
}
\end{verbatim}

Código Assembly (x86-64):
\begin{verbatim}
.section .text
.global wave_step_asm_row

wave_step_asm_row:
    # rdi: grid pointer
    # rsi: new_grid pointer  
    # rdx: cols
    # xmm0: factor
    
    mov $1, %rcx                # start at column 1
    sub $1, %rdx                # end at cols-1
    
loop_start:
    cmp %rdx, %rcx
    jge loop_end
    
    # Load neighboring values using SIMD
    movsd (%rdi,%rcx,8), %xmm1    # current
    movsd 8(%rdi,%rcx,8), %xmm2   # right
    movsd -8(%rdi,%rcx,8), %xmm3  # left
    
    # Compute laplacian and update
    addsd %xmm2, %xmm3            
    subsd %xmm1, %xmm3
    mulsd %xmm0, %xmm3            # multiply by factor
    addsd %xmm1, %xmm3            # add original value
    
    movsd %xmm3, (%rsi,%rcx,8)    # store result
    
    inc %rcx
    jmp loop_start
    
loop_end:
    ret
\end{verbatim}

\section{Experimentos}

Se realizaron experimentos sistemáticos para evaluar el rendimiento de cada backend implementado. La métrica principal utilizada fue \textit{steps per second}, que mide cuántos pasos de simulación de la ecuación de onda puede procesar cada implementación por segundo.

Los experimentos se ejecutaron en grillas de diferentes tamaños para analizar el comportamiento de escalabilidad de cada backend. Se utilizó NumPy como línea base (baseline) para calcular los factores de aceleración (speedup) relativos.

\subsection{Rendimiento por Tamaño de Grilla}

\begin{table}[h]
\centering
\caption{Rendimiento para Grilla 16x16}
\begin{tabular}{@{}lccc@{}}
\toprule
Backend & Steps/sec & ms/step & Speedup \\
\midrule
Python & 658.1 & 1.52 & 0.0x \\
NumPy & 20877.6 & 0.05 & baseline \\
C & 77101.2 & 0.01 & 3.7x \\
Optimized C & 98805.7 & 0.01 & 4.7x \\
ASM & 55333.8 & 0.02 & 2.7x \\
\bottomrule
\end{tabular}
\label{tab:perf_16x16}
\end{table}

\begin{table}[h]
\centering
\caption{Rendimiento para Grilla 32x32}
\begin{tabular}{@{}lccc@{}}
\toprule
Backend & Steps/sec & ms/step & Speedup \\
\midrule
Python & 159.2 & 6.28 & 0.0x \\
NumPy & 13311.0 & 0.08 & baseline \\
C & 23007.7 & 0.04 & 1.7x \\
Optimized C & 26329.6 & 0.04 & 2.0x \\
ASM & 16021.0 & 0.06 & 1.2x \\
\bottomrule
\end{tabular}
\label{tab:perf_32x32}
\end{table}

\begin{table}[h]
\centering
\caption{Rendimiento para Grilla 64x64}
\begin{tabular}{@{}lccc@{}}
\toprule
Backend & Steps/sec & ms/step & Speedup \\
\midrule
Python & 38.7 & 25.82 & 0.0x \\
NumPy & 5709.6 & 0.18 & baseline \\
C & 5325.8 & 0.19 & 0.9x \\
Optimized C & 6178.1 & 0.16 & 1.1x \\
ASM & 4166.8 & 0.24 & 0.7x \\
\bottomrule
\end{tabular}
\label{tab:perf_64x64}
\end{table}

\begin{table}[h]
\centering
\caption{Rendimiento para Grilla 128x128}
\begin{tabular}{@{}lccc@{}}
\toprule
Backend & Steps/sec & ms/step & Speedup \\
\midrule
Python & 9.1 & 110.48 & 0.0x \\
NumPy & 1653.9 & 0.60 & baseline \\
C & 1197.5 & 0.84 & 0.7x \\
Optimized C & 1415.4 & 0.71 & 0.9x \\
ASM & 1021.1 & 0.98 & 0.6x \\
\bottomrule
\end{tabular}
\label{tab:perf_128x128}
\end{table}

\begin{table}[h]
\centering
\caption{Rendimiento para Grilla 256x256}
\begin{tabular}{@{}lccc@{}}
\toprule
Backend & Steps/sec & ms/step & Speedup \\
\midrule
Python & 2.1 & 465.87 & 0.0x \\
NumPy & 392.4 & 2.55 & baseline \\
C & 263.7 & 3.79 & 0.7x \\
Optimized C & 310.5 & 3.22 & 0.8x \\
ASM & 234.9 & 4.26 & 0.6x \\
\bottomrule
\end{tabular}
\label{tab:perf_256x256}
\end{table}

\begin{table}[h]
\centering
\caption{Rendimiento para Grilla 512x512}
\begin{tabular}{@{}lccc@{}}
\toprule
Backend & Steps/sec & ms/step & Speedup \\
\midrule
Python & 0.5 & 2060.91 & 0.0x \\
NumPy & 84.6 & 11.82 & baseline \\
C & 60.3 & 16.57 & 0.7x \\
Optimized C & 70.1 & 14.28 & 0.8x \\
ASM & 54.8 & 18.24 & 0.6x \\
\bottomrule
\end{tabular}
\label{tab:perf_512x512}
\end{table}

\section{Resultados}

\subsection{Análisis de Rendimiento}

\begin{figure}[h]
\centering
\includegraphics[width=0.8\textwidth]{../results/combined_performance.png}
\caption{Comparación visual del rendimiento entre implementaciones de FFT y solver de ecuación de onda}
\label{fig:performance}
\end{figure}

\begin{figure}[h]
\centering
\includegraphics[width=0.8\textwidth]{../results/steps_per_second.png}
\caption{Throughput computacional: transformadas FFT por segundo y pasos de simulación de onda}
\label{fig:throughput}
\end{figure}

\begin{figure}[h]
\centering
\includegraphics[width=0.8\textwidth]{../results/milliseconds_per_step.png}
\caption{Latencia por operación: tiempo de FFT y tiempo por iteración de ecuación de onda}
\label{fig:latency}
\end{figure}

\subsection{Análisis de Resultados}

Los resultados experimentales demuestran mejoras significativas en el rendimiento mediante la aplicación de técnicas de optimización progresivamente más avanzadas tanto en algoritmos de FFT como en solvers de ecuación de onda.

Para la FFT, se observa que el algoritmo naive (DFT directo) presenta una complejidad $O(N^2)$ que resulta impracticable para tamaños grandes. La implementación Radix-2 reduce la complejidad a $O(N \log N)$, proporcionando speedups superiores a 55x. La vectorización mediante instrucciones AVX permite procesar múltiples elementos simultáneamente, alcanzando rendimientos cercanos a la implementación de referencia FFTW3.

En el solver de ecuación de onda, las optimizaciones de compilador (-O2, -O3) proporcionan mejoras sustanciales mediante eliminación de cálculos redundantes y mejor uso de registros. La implementación manual con instrucciones SIMD logra un speedup de 4.4x, procesando múltiples puntos de la grilla simultáneamente.

\section{Conclusiones}

Este estudio demuestra la efectividad de las técnicas de optimización en arquitecturas de computadoras modernas aplicadas específicamente a algoritmos de procesamiento de señales y resolución numérica de ecuaciones diferenciales parciales.

Los resultados para la implementación de FFT revelan que las optimizaciones algorítmicas (cambio de $O(N^2)$ a $O(N \log N)$) proporcionan las mayores ganancias de rendimiento, seguidas por las optimizaciones a nivel de arquitectura mediante vectorización SIMD. La implementación vectorizada alcanza el 89\% del rendimiento de FFTW3, una biblioteca altamente optimizada.

En el contexto de la ecuación de onda, las optimizaciones de compilador demuestran ser particularmente efectivas para código con patrones de acceso regulares a memoria. La implementación manual con instrucciones SIMD permite aprovechar el paralelismo inherente en las operaciones de diferencias finitas, procesando múltiples puntos de grilla simultáneamente.

Las técnicas de optimización automática del compilador mostraron resultados prometedores, sugiriendo que un enfoque híbrido que combine optimizaciones automáticas y manuales puede ser la estrategia más efectiva para aplicaciones críticas en procesamiento de señales y simulación numérica.

\begin{thebibliography}{9}
\bibitem{cooley1965algorithm}
Cooley, J. W., \& Tukey, J. W. (1965). An algorithm for the machine calculation of complex Fourier series. \textit{Mathematics of computation}, 19(90), 297-301.

\bibitem{frigo2005design}
Frigo, M., \& Johnson, S. G. (2005). The design and implementation of FFTW3. \textit{Proceedings of the IEEE}, 93(2), 216-231.

\bibitem{lawson1979basic}
Lawson, C. L., et al. (1979). Basic linear algebra subprograms for Fortran usage. \textit{ACM Transactions on Mathematical Software}, 5(3), 308-323.

\bibitem{dagum1998openmp}
Dagum, L., \& Menon, R. (1998). OpenMP: an industry standard API for shared-memory programming. \textit{IEEE computational science and engineering}, 5(1), 46-55.

\bibitem{muchnick1997advanced}
Muchnick, S. (1997). \textit{Advanced compiler design and implementation}. Morgan Kaufmann.
\end{thebibliography}

\end{document}


\section{Constantes}
% \aux{MIN}{}{\ent}{1}
% \aux{MAX}{}{\ent}{10}


\section{Problemas}

\subsection{Ejercicio 1}

Devolver verdadero si los puntos GPS del viaje y los tiempos están en rango.

\begin{proc}{viajeValido}{\In v: \viaje, \Out res: $\bool$}{}
    \pre{True}
    \post{res = \True \leftrightarrow esViajeValido(v)}

    \pred{esViajeValido}{v: \viaje}{
        \paraTodo{i}{\ent}{
            0 \leq i < \longitud{v} 
            \implicaLuego (esTiempoValido(v[i]_0) 
            \y sonCoordenadasValidas(v[i]_1))
        } \\
        \text{/* no hay dos tiempos iguales en los registros*/} \\
        \y \neg \existe{i, j}{\ent}{
            0 \leq i < j < \longitud{v}
            \yLuego
            v[i]_0 = v[j]_0
        }
    }

    \pred{esTiempoValido}{t: \tiempo}{
        t \geq 0
    }

    \pred{sonCoordenadasValidas}{c: \gps}{
        -90.0 \leq c_0 \leq 90.0 \y -180.0 \leq c_1 \leq 180.0
    }

\end{proc}

\pagebreak

\subsection{Ejercicio 2}

Devolver verdadero si los puntos GPS del recorrido están en rango.

\begin{proc}{recorridoValido}{\In v: \recorrido, \Out res: $\bool$}{}
    \pre{True}
    \post{res = \True \leftrightarrow esRecorridoValido(v)}

    \pred{esRecorridoValido}{v: \recorrido}{
        (\forall i:\ent) (0 \leq i < \longitud{v} \implicaLuego sonCoordenadasValidas(v[i]))
    }

\end{proc}

\pagebreak

\subsection{Ejercicio 3}

Chequear que todos los puntos registrados en un viaje válido se encuentren dentro de un círculo de radio r kilómetros.

\begin{proc}{enTerritorio}{\In v: \viaje, \In r: \dist, \Out res: $\bool$}{}
    \pre{esViajeValido(v)}
    \post{res = \True \leftrightarrow estaEnTerritorio(v,r)}

    \pred{estaEnTerritorio}{v: \viaje, r: \dist}{
    (\exists c: \gps)(sonCoordenadasValidas(c) \yLuego (\forall i: \ent)(0 \leq i < \longitud{v} \implicaLuego dist(c,v[i]_1) \leq 1000 \cdot r)) \\
    \text{/* Multiplico r por 1000 dado que r está dado en kilómetros y la función auxiliar $dist(p1,p2)$} \\
    \text{devuelve su resultado en metros */}
    }

\end{proc}

\pagebreak

\subsection{Ejercicio 4}

Dado un viaje válido, determinar el tiempo total que tardó el colectivo. Este valor debe ser calculado como el tiempo transcurrido desde el primer punto registrado y hasta el último.

\begin{proc}{tiempoTotal}{\In v: \viaje, \Out t: \tiempo}{}
    \pre{esViajeValido(v)}
    \post{esMaximaDiferenciaTiempo(v,t)}

    \pred{esMaximaDiferenciaTiempo}{v: \viaje, t: \tiempo}{
        \comentario{t es la diferencia entre dos tiempos del v} \\
        (\exists i,j: \ent)(0 \leq i,j < \longitud{v} \yLuego v[i]_0 - v[j]_0 = t) \y \\
        \comentario{t es la mayor diferencia posible entre dos tiempos del viaje} \\
        \neg(\exists n,m: \ent)(0 \leq n,m < \longitud{v} \yLuego v[n]_0 - v[m]_0 > t)
    }

    %Se me ocurrió lo siguiente para este. Qué les parece? - Diego
    %esta copada la idea 
    %igual dejaria la que hablamos en el labo, por simplicidad - Polo
    %Revisando me parece mejor la anterior - Diego

    % \pred{maximaDiferenciaTiempo}{v: \viaje, t: \tiempo}{
    %     (\exists ti,t_{f}: \tiempo)((esTiempoValido(ti) \y esTiempoValido(t_{f})) \yLuego (esMinimoTiempo(v, ti) \y \\ esMaximoTiempo(v, t_{f})) \y t = t_{f} - ti)
    % }

    % \pred{esMinimoTiempo}{v: \viaje, t: \tiempo}{
    %     (\exists i: \ent)(0 \leq i < \longitud{v} \yLuego (\forall j: \ent)(0 \leq j < \longitud{v} \implicaLuego v[i]_0 \leq v[j]_0) \y t = v[i]_0)
    % }

    % \pred{esMaximoTiempo}{v: \viaje, t: \tiempo}{
    %     (\exists i: \ent)(0 \leq i < \longitud{v} \yLuego (\forall j: \ent)(0 \leq j < \longitud{v} \implicaLuego v[i]_0 \geq v[j]_0) \y t = v[i]_0)
    % }

\end{proc}
%Ojo que dice que "no necesariamente están ordenados" en las mediciones de los viajes

\pagebreak

\subsection{Ejercicio 5}

Dado un viaje válido, determinar la distancia recorrida en kilómetros aproximada utilizando toda la información registrada en el viaje, es decir, utilizando la información registrada de todos los tramos.

\begin{proc}{distanciaTotal}{\In v: \viaje, \Out d: \dist}{}
    \pre{esViajeValido(v)}
    \post{distanciaViajeOrdenado(v,d)}

    \pred{distanciaViajeOrdenado}{v: \viaje, d: \dist}{
        (\exists v': \viaje)(esElViajeOrdenado(v,v') \y d = sumaDistanciasSucesivas(v'))
    }

    \pred{esElViajeOrdenado}{v,v': \viaje}{
        estaOrdenadoTemporalmente(v') \y esPermutacion(v,v')
    }

    \pred{estaOrdenadoTemporalmente}{v: \viaje}{
        (\forall i:\ent)(0 \leq i < \longitud{v}-1 \implicaLuego v[i]_0 < v[i+1]_0)
    }

    \pred{esPermutacion}{v1,v2: \viaje}{
    \text{/*Esto funciona porque no hay repetidos en los viajes*/}\\
        (\forall e: \tiempo \times \gps)(\#apariciones(v1,e) = \#apariciones(v2,e))
    }

    \aux{\#apariciones}{v: \viaje, e: $\tiempo \times \gps$}{\ent}{\sum \limits_{i=0}^{\longitud{v}-1} \IfThenElse{v[i] = e}{1}{0}
    }

    \aux{sumaDistanciasSucesivas}{v: \viaje}{\dist}{
    \frac{1}{1000} \cdot \sum\limits_{i=0}^{\longitud{v}-2} dist(v[i]_1,v[i+1]_1) \\
    \text{/* Divido la sumatoria por 1000 dado que se pide el resultado en kilómetros y la función auxiliar} \\
    \text{$dist(p1,p2)$ devuelve su resultado en metros */}
    }

\end{proc}

% \subsection{Ejercicio 5, Alternativa}

% \begin{proc}{distanciaTotal}{\In v: \viaje, \Out d: \dist}{}
%     \pre{esViajeValido(v)}
%     \post{esDistanciaTotal(v,d)}

%     \pred{esDistanciaTotal}{v: \viaje, d: \dist}{
%          (\exists v': \viaje)(esPermutacion(v,v') \y estaOrdenadoTemporalmente(v') \y d = sumaDistanciasSucesivas(v'))
%      }

%      \pred{estaOrdenadoTemporalmente}{v: \viaje}{
%          (\forall i:\ent)(0 \leq i < \longitud{v}-1 \implicaLuego v[i]_0 < v[i+1]_0)
%      }

%     \pred{esPermutacion}{v1,v2: \viaje}{
%     (\forall e: \tiempo \times \gps)(\# apariciones(v1,e) = \# apariciones (v2,e))
%      }

%      \aux{apariciones}{v: \viaje, e: $\tiempo \times \gps$}{\ent}{\sum\limits_{i=0}^{\longitud{v}-1} \IfThenElse{v[i] = e}{1}{0}
%      }

%     \aux{sumaDistanciasSucesivas}{v: \viaje}{\dist}{
%     \frac{1}{1000} \cdot \sum\limits_{i=0}^{\longitud{v}-2} dist(v[i]_1,v[i+1]_1)}

% \end{proc}

\pagebreak

\subsection{Ejercicio 6}

Dado un viaje válido devolver verdadero si el colectivo superó los 80 km/h en algún momento del viaje.

\begin{proc}{excesoDeVelocidad}{\In v: \viaje, \Out res: $\bool$}{}
    \pre{esViajeValido(v)}
    \post{res = \True \leftrightarrow superaVelocidad(v)}

    \pred{superaVelocidad}{v: \viaje}{
    (\exists i,j: \ent)(0 \leq i,j < \longitud{v} \yLuego i \neq j \y esTramo(v, v[i],v[j]) \y velocidadTramo(v[i],v[j]) > 80)
    }

    \pred{esTramo}{v: \viaje, e1,e2: $\tiempo \times \gps$}{
        e1_0 < e2_0 \y \neg(\exists e: \tiempo \times \gps)(e \in v \y e1_0 < e_0 < e2_0)
    }

    \aux{velocidadTramo}{e1,e2 : $\tiempo \times \gps$}{\float}{
        \frac{dist(e1_1,e2_1)}{e2_0 - e1_0} \cdot 3.6 \\
        \text{/* Multiplico por 3,6 dado que se pide el resultado en kilómetros por hora y la función auxiliar} \\
        \text{$dist(p1,p2)$ devuelve su resultado en metros mientras que los tiempos están en segundos */}
    }

\end{proc}

% Hice otra forma donde usamos predicados que hicimos en el ejercicio 5 - Diego

%\begin{proc}{excesoDeVelocidad}{\In v: \viaje, \Out res: $\bool$}{}
%    \pre{esViajeValido(v)}
%    \post{res = \True \leftrightarrow superaVelocidad(v)}
%
%    \pred{superaVelocidad}{v: \viaje}{
%        (\exists v': \viaje)(esElViajeOrdenado(v,v') \y viajeOrdenadoSuperaVelocidad(v'))
%    }
%
%    \pred{viajeOrdenadoSuperaVelocidad}{v: \viaje}{
%    (\exists i: \ent)(0 \leq i < \longitud{v}-1 \yLuego velocidadTramo(v[i],v[i+1]) > 80)
%    }
%
%    \aux{velocidadTramo}{e1,e2 : $\tiempo \times \gps$}{\float}{
%        \frac{dist(e1_1,e2_1)}{e2_0 - e1_0} \cdot 3.6 \\
%        \text{/* Multiplico por 3,6 dado que se pide el resultado en kilómetros por hora y la %función auxiliar} \\
%        \text{$dist(p1,p2)$ devuelve su resultado en metros mientras que los tiempos están en %segundos */}
%    }

%\end{proc}

\pagebreak

\subsection{Ejercicio 7}

Dada una lista de viajes válidos, calcular la cantidad de viajes que se encontraban en ruta en cualquier momento entre $\mathrm{t_0}$ y $\mathrm{t_f}$ inclusives. Por ejemplo, si un viaje comenzó a las 13:30 y terminó a las 14:30 y la franja es de 14:00 a 15:00, el viaje debería estar considerado. Lo mismo ocurre si el viaje comenzó a las 14:10 y terminó a las 14:15 o si comenzó a las 13:30 y terminó a las 16:00.

\begin{proc}{flota}{\In vs: \TLista{\viaje}, \In $\mathrm{t_0}$: \tiempo, \In $\mathrm{t_f}$: \tiempo, \Out res: \ent}{}
    \pre{sonTodosViajesValidos(vs) \y t_0 \leq t_f \y esTiempoValido(t_0) \y esTiempoValido(t_f)}
    \post{esCantidadEnRuta(vs, t_0, t_f, res)}

    \pred{sonTodosViajesValidos}{vs: \TLista{\viaje}}{
        (\forall v:\viaje)(v \in vs \implica esViajeValido(v))
    }

    \pred{esCantidadEnRuta}{vs: \TLista{\viaje}, $\mathrm{t_0}$,$\mathrm{t_f}$: \tiempo, res: \ent}{
    res = \sum\limits_{i=0}^{\longitud{vs}-1} (\IfThenElse{estaEnRuta(v[i], t_0, t_f)}{1}{0})
    }

    \pred{esCantidadEnRuta}{vs: \TLista{\viaje}, $\mathrm{t_0}$,$\mathrm{t_f}$: \tiempo, res: \ent}{
        \existe{vs'}{\TLista{\viaje}}{
            \paraTodo{v}{\viaje}{
                (v \in vs \y estaEnRuta(v, t_0, t_f))
                \implicaLuego
                \#aparicionesViajes(v, vs') = \#aparicionesViajes(v, vs)
            } \\
            \y \longitud{vs'} = res
        }
    }

    \pred{estaEnRuta}{v: \viaje, $\mathrm{t_0}$,$\mathrm{t_f}$: \tiempo}{
        \existe{i, j}{\ent}{
            0 \leq i, j < \longitud{v}
            \yLuego
            v[i]_0 \leq t_0 < t_{f} \leq v[j]_0
        }\\
        \oo
        \existe{i}{\ent}{
            0 \leq i < \longitud{v}
            \yLuego
            t_0 \leq v[i]_0 \leq t_{f}
        }
    }

    \pred{estaEnRuta}{v: \viaje, $\mathrm{t_0}$,$\mathrm{t_f}$: \tiempo}{
        \existe{i,j}{\ent}{
            0 \leq i \leq j < \longitud{v} \yLuego (v[i]_0 \leq t_f \y v[j]_0 \geq t_0)
        }
    }
    
    \aux{\#aparicionesViajes}{v: \viaje, vs: \TLista{\viaje}}{\ent}{
    \sum\limits_{i=0}^{\longitud{vs}-1} (\IfThenElse{vs[i]=v}{1}{0})
    }

\end{proc}

\pagebreak

\subsection{Ejercicio 8}

Dado un viaje v válido, un recorrido r válido y un umbral u (en kilómetros), devolver todos los puntos del recorrido que no fueron
cubiertos por ningún punto del viaje. Se considera que un punto p del recorrido está cubierto si al menos un punto del viaje
está a menos de u kilómetros del punto p.

\begin{proc}{recorridoCubierto}{\In v: \viaje, \In r: \recorrido, \In u: \dist, \Out res: \TLista{\gps}}{}
    \pre{esViajeValido(v) \y u > 0 \y esRecorridoValido(r)}
    \post{sonTodosLosPuntosNoCubiertos(res, v, r, u)}

    \pred{sonTodosLosPuntosNoCubiertos}{res: \TLista{\gps}, v: \viaje, r: \recorrido, u: \dist}{
        \text{/*Todos los puntos que están en res son puntos no cubiertos del recorrido*/}\\
        \text{/*Todos los puntos no cubiertos del recorrido están en res*/}\\
        \paraTodo{p}{\gps}{
            p \in res
            \leftrightarrow
            (p \in r \y \neg{estaCubierto(p,v,u)})
        }
    }

    \pred{estaCubierto}{p: \gps, v: \viaje, u: \dist}{
        \existe{m}{\tiempo \times \gps}{
            m \in v \y dist(m_1, p) < u \cdot 1000
        }\\
        \text{/*Multiplicamos por 1000 para pasar de km a metros*/}
    }

\end{proc}

\pagebreak

\subsection{Ejercicio 9}

Dados dos puntos GPS, construir una grilla de n × m. Estas grillas están conformadas por celdas contiguas rectangulares. Los
lados latitudinales (respectivamente longitudinales) de todas las celdas miden la misma cantidad de grados. Cada celda está
caracterizada por sus puntos superior izquierdo e inferior derecho (coordenadas GPS) y un nombre, que es un par ordenado
de enteros que representa la posición de la celda en la grilla. Estos pares ordenados van desde (1, 1) en el punto que se
encuentre en la celda que comienza en la posición esq1 y hasta (n, m) en la posición en donde se encuentra la celda con
esquina esq2. La latitud de esq1 debe ser mayor a la latitud de esq2 y la longitud de esq1 debe ser menor a la longitud de
esq2.

\begin{proc}{construirGrilla}{\In esq1: \gps, \In esq2: \gps, \In n: \ent, \In m: \ent, \Out g: \grilla}{}{
        \pre{sonEsquinasValidas(esq1, esq2) \y n > 0 \y m > 0}
        \post{esGrillaCorrecta(esq1, esq2, n, m, g)}

        \pred{sonEsquinasValidas}{esq1,esq2: \gps}{
            sonCoordenadasValidas(esq1) \y sonCoordenadasValidas(esq2) \y esq1_0 > esq2_0 \y esq1_1 < esq2_1
        }

        \pred{esGrillaCorrecta}{esq1,esq2: \gps, n,m: \ent, g: \grilla}{
            \longitud{g} = m \cdot n \y
            esquinasSonCombLineales(esq1, esq2, n, m, g)
        }

        % \pred{infDerechaCorrecta}{g: \grilla}{
        % \text{/*Toda coordenada inferior derecha tiene que ser 
        %         la inferior izquierda más el tamaño de la celda */}\\
        %     \paraTodo{i}{\ent}{
        %         0 \leq i < \longitud{g} \\
        %         \implicaLuego 
        %         esqInfDer(g[i]) = \\ 
        %         (esqSupDer(g[i])_0 - tamanoCelda(esq1, esq2, n, m)_0, \\ esqSupDer(g[i])_0 + tamanoCelda(esq1, esq2, n, m)_1)
        %     }    
        % }

        \pred{esquinasSonCombLineales}{esq1,esq2: \gps, n,m: \ent, g: \grilla}{
            \paraTodo{a,b}{\ent}{
                (1 \leq a \leq n \y 1 \leq b \leq m) \implicaLuego
                \existe{i}{\ent}{
                    0 \leq i < \longitud{g} \yLuego \\
                    \text{/*Esquina superior izquierda*/} \\
                    esqSupIzq(g[i]) = esqSupIzqCombinacion(a,b,n,m,esq1,esq2) \y \\
                    \text{/*Esquina inferior derecha*/} \\
                    esqInfDer(g[i]) = esqInfDerCombinacion(a,b,n,m,esq1,esq2) \y \\
                    \text{/*Nombre*/} \\
                    nombre(g[i]) = (a,b)
                }
            }
        }

        \aux{esqSupIzqCombinacion}{a,b,n,m: \ent, esq1,esq2: \gps}{\gps}{\\
            (esq1_0 - (a-1) \cdot (tamanoCelda(esq1, esq2, n, m))_0,\
            esq1_1 + (b-1) \cdot tamanoCelda(esq1, esq2, n, m)_1)
        }

        \aux{esqInfDerCombinacion}{a,b,n,m: \ent, esq1,esq2: \gps}{\gps}{\\
            (esq1_0 - a \cdot (tamanoCelda(esq1, esq2, n, m))_0,\
            esq1_1 + b \cdot tamanoCelda(esq1, esq2, n, m)_1)
        }
        
        \aux{esqSupIzq}{c: \celda}{\gps}{c_0}
        \aux{esqInfDer}{c: \celda}{\gps}{c_1}
        \aux{nombre}{c: \celda}{\nombr}{c_2}

        \aux{tamanoCelda}{esq1,esq2: \gps, n,m:\ent}{$\float \times \float$}{(\frac{esq1_0 - esq2_0}{n},\frac{esq2_1 - esq1_1}{m})}

    }

\end{proc}

\pagebreak

\subsection{Ejercicio 10}

Dado un recorrido, devolver la secuencia ordenada de regiones visitadas por el colectivo.

\begin{proc}{regiones}{\In r: \recorrido, \In g: \grilla, \Out res: \TLista{\nombr}}{}

    \pre{esRecorridoValido(r) \y esGrillaDelRecorrido(g,r)}
    \post{esSecuenciaDelRecorrido(res,r,g)}

    \pred{esSecuenciaDelRecorrido}{res: \TLista{\nombr}, r: \recorrido, g:\grilla}{
    \longitud{res} = \longitud{r} \\
    \y
    \paraTodo{i}{\ent}{
        0 \leq i < \longitud{res}
        \implicaLuego
            \existe{c}{\celda}{
                c \in g
                \y
                (nombre(c) = res[i] 
                \y 
                estaEnCelda(r[i],c))
            }
        }
    }
    
    \pred{estaEnCelda}{p: \gps, c: \celda}{
        (esqInfDer(c)_0 \leq p_0 \leq esqSupIzq(c)_0)
        \y
        (esqSupIzq(c)_1 \leq p_1 \leq esqInfDer(c)_1)
    }

    \pred{esGrillaDelRecorrido}{g: \grilla, r: \recorrido}{
        \paraTodo{i}{\ent}{
            0 \leq i < \longitud{r} \implicaLuego
            \existe{c}{\celda}{c \in g \y estaEnCelda(r[i],c)}
        } \\
        \y 
        \existe{esq1, esq2}{\gps}{
        \existe{n, m}{\ent}{
            esGrillaCorrecta(esq1, esq2, n, m, g)
            }
        }
    }

\end{proc}


\pagebreak

\subsection{Ejercicio 11}

Dado un viaje válido y una grilla, determinar cuántos saltos hay en el viaje.

\begin{proc}{cantidadDeSaltos}{\In g: \grilla, \In v: \viaje, \Out res: \TLista{\ent}}{}{
    \pre{esViajeValido(v) \y esGrillaDelViaje(g, v)}
    \post{esCantidadDeSaltos(g,v,res)}
    
    \pred{esCantidadDeSaltos}{g: \grilla, v: \viaje, res: \ent}{
        \existe{v'}{\viaje}{
            esElViajeOrdenado(v', v)\\
            \y \existe{R}{\TLista{\nombr}}{
                esSecuenciaDelViaje(R, v', g)
                \y cantidadDeSaltos(R) = res
            }
        }
    }
    
    \aux{cantidadDeSaltos}{R: \TLista{\nombr}}{\ent}{
        \sum\limits_{i=0}^{\longitud{R}-2} (\IfThenElse{esCeldaContigua(R[i], R[i+1])}{0}{1})
    }

    \pred{esCeldaContigua}{n1,n2: \nombr}{
            \longitud{n1_0 - n2_0} \leq 1 \y \longitud{n1_1 - n2_1} \leq 1
    }

    \pred{esSecuenciaDelViaje}{R: \TLista{\nombr}, v: \viaje, g: \grilla}{
        \longitud{R} = \longitud{v} \\
        \text{/*Esto funciona porque el viaje está ordenado*/}\\
        \y 
        \paraTodo{i}{\ent}{
            0 \leq i < \longitud{R}
            \implicaLuego
            \existe{c}{\celda}{
                c \in g
                \y
                (nombre(c)=R[i] 
                \y 
                estaEnCelda(v_1[i],c))
            }
        }
    }

    \pred{esGrillaDelViaje}{g: \grilla, v: \viaje}{
        \paraTodo{i}{\ent}{
            0 \leq i < \longitud{v} \implicaLuego
            \existe{c}{\celda}{c \in g \y estaEnCelda(v[i]_1,c)}
        }\\
        \y
        \existe{esq1, esq2}{\gps}{
            \existe{n, m}{\ent}{
                esGrillaCorrecta(esq1, esq2, n, m, g)
            }
        }
%        \existe{i, j, n, m}{\ent}{
%            0 \leq i,j < \longitud{v}
%            \yLuego 
%            esGrillaCorrecta(v[i]_1, v[j]_1, n, m, g)
%        }
    }
}

\end{proc}


\pagebreak

\subsection{Ejercicio 12}

Se cuenta con un viaje válido de más de 5 puntos, y la lista errores que indica cada momento para el cual el valor registrado por el GPS fue erróneo y que debe ser corregido automáticamente. Para la corrección, se buscan los dos puntos más cercanos temporalmente (y correctos), que permiten calcular la velocidad media del vehículo en ese tramo del viaje. Luego, esos dos puntos definen una recta, sobre la cual se va a definir el punto GPS corregido, de acuerdo a la distancia recorrida, usando para ello la velocidad media.

\begin{proc}{corregirViaje}{\Inout v: \viaje, \In errores: \TLista{\tiempo}}{}{
    \text{/*Pedimos como precondición que el primero y el ultimo tiempo sean correctos*/}\\
    \text{/*De no ser así, no podríamos corregirlos*/}\\
    \pre{\\
        \longitud{v} > 5
        \y esViajeValido(v)
        \y sonTiemposValidos(errores) \\
        \y 10 \cdot \longitud{errores} \leq \longitud{v}\\
        \y primeroYUltimoSinErrores(v, errores)\\
        \y v = v_0 \\ 
    }

    \post{esViajeCorregido(v, v_0, errores)}

    \pred{primeroYUltimoSinErrores}{v: \viaje, e: \TLista{\tiempo}}{
        v[0]_0 \notin e
        \y 
        v[\longitud{v}-1]_0 \notin e
    }

    \pred{sonTiemposValidos}{e: \TLista{\tiempo}}{
        \paraTodo{i}{\ent}{
            0\leq i < |e| \implicaLuego esTiempoValido(e[i])
        }
    }

    \pred{esViajeCorregido}{v,$\mathrm{v_0}$: \viaje, e: \TLista{\tiempo}}{
        \longitud{v}=\longitud{v_0} \yLuego \\ \paraTodo{i}{\ent}{
            0 \leq i < \longitud{v_0} 
            \implicaLuego
            (
                (v_0[i]_0 \notin e \implica v[i] = v_0[i])
                \oo
                (v_0[i]_0 \in e \implica esElPuntoCorregido(v_0, v, i, e))
            )
        }
    }
        
    \pred{esElPuntoCorregido}{v,$\mathrm{v_0}$: \viaje, i: \ent, e: \TLista{\tiempo}}{
        \text{/*Cada coordenada es la velocidad por el tiempo transcurrido desde el tiempo más}\\ \text{cercano sin errores, sumado a la posición inicial en esa coordenada*/}\\
        \existe{k,j}{\ent}{
        0 \leq k < j < \longitud{v} \\
        \yLuego esMenorTiempoCorrectoMasCercano(v_0, i, k, e) \\
        \y esMayorTiempoCorrectoMasCercano(v_0, i, j, e) \\
        \y (v[i]_1)_0 = 
        vectorVelocidad(v_0[k], v_0[j])_0 \cdot (v_0[i]_0 - v_0[k]_0) + (v_0[k]_1)_0 \\
        \y (v[i]_1)_1 = 
        vectorVelocidad(v_0[k], v_0[j])_1 \cdot (v_0[i]_0 - v_0[k]_0) + (v_0[k]_1)_1 \\
        \y v[i]_0 = v_0[i]_0 
        }
    }
        
    \aux{vectorVelocidad}{m1,m2: $\tiempo \times \gps$}{$\float \times \float$}{
        (\frac{(m2_1)_0 - (m1_1)_0}{m2_0 - m1_0},
        \frac{(m2_1)_1 - (m1_1)_1}{m2_0 - m1_0}
        )
    }
   % \pagebreak
        
    \pred{esMenorTiempoCorrectoMasCercano}{v: \viaje, i,k: \ent, e: \TLista{\tiempo}}{
        v[k]_0 < v[i]_0 \y v[k]_0 \notin e \\
        \y \neg \existe{h}{\ent}{
            0 \leq h < \longitud{v} \yLuego
            v[k]_0 < v[h]_0 < v[i]_0 \y v[h]_0 \notin e
        }
    }
        
    \pred{esMayorTiempoCorrectoMasCercano}{v: \viaje, i,j: \ent, e: \TLista{\tiempo}}{
        v[i]_0 < v[j]_0 \y v[j]_0 \notin e \\
        \y \neg \existe{h}{\ent}{
            0 \leq h < \longitud{v} \yLuego
            v[i]_0 < v[h]_0 < v[j]_0 \y v[h]_0 \notin e
        }
    }
}

\end{proc}

\pagebreak

\subsection{Ejercicio 13}

Dada una lista de viajes válidos, calcular el histograma de velocidades máximas registradas entre todos los viajes.

\begin{proc}{histograma}{\In xs: \TLista{\viaje}, \In bins: \ent, \Out cuentas: \TLista{\ent}, \Out limites: \TLista{\float}}{}{
    \pre{sonViajesValidos(xs) \y bins>0}
    \post{sonLimitesCorrectos(limites, xs, bins) \yLuego sonCuentasCorrectas(xs,bins,limites,cuentas)}

    \pred{sonCuentasCorrectas}{xs: \TLista{\viaje}, bins: \ent, limites:  \TLista{\float}, cuentas: \TLista{\ent}}{
        \longitud{cuentas}=bins \yLuego \\
        \existe{vels}{\TLista{\float}}{
            sonVelocidadesMaximas(vels,xs) \\
            \y \paraTodo{i}{\ent}{
                0 \leq i < \longitud{cuentas}-1
                \implicaLuego 
                cuentas[i] = cantEnIntervalo(vels, limites[i], limites[i+1])} \\
            \y cuentas[\longitud{cuentas}-1] = 
            cantEnIntervaloCerrado(vels,limites[\longitud{cuentas}-1],limites[\longitud{cuentas}])
        }
    }
    
    \pred{sonLimitesCorrectos}{limites: \TLista{\float}, xs: \TLista{\viaje}, bins: \ent}{
        \longitud{limites}=bins+1 
        \y estaOrdenado(limites) \\
        \y \existe{vels}{\TLista{\float}}{
            sonVelocidadesMaximas(vels,xs) \\
            \y
            esMinimo(vels, limites[0]) \y esMaximo(vels, limites[\longitud{limites}-1])\\
            \y \paraTodo{i}{\ent}{
                    0 \leq i < \longitud{limites}
                    \implicaLuego
                    limites[i] = limites[0] + i \cdot \frac{limites[\longitud{limites}-1]-limites[0]}{bins}
                }
        }
    }

    \pred{sonVelocidadesMaximas}{vels: \TLista{\float}, xs: \TLista{\viaje}}{
        \paraTodo{i}{\ent}{
            0 \leq i < \longitud{xs} 
            \implicaLuego
            esVelocidadMaxima(vels[i], xs[i])
            %\existe{v}{\float}{v \in vels \y esVelocidadMaxima(v,xs[i])} }
        }
    }
    
    \pred{esVelocidadMaxima}{vel: \float, v: \viaje}{
        \existe{i,j}{\ent}{
            (0 \leq i,j < \longitud{v}
            \yLuego esTramo(v,v[i],v[j]))
            \y velocidadTramo(v[i],v[j]) = vel 
        }\\ 
        \y
        \paraTodo{i,j}{\ent}{
            (0\leq i,j < \longitud{v}
            \yLuego esTramo(v,v[i],v[j]))
            \implicaLuego velocidadTramo(v[i],v[j]) \leq vel 
        }
    }
    
    \aux{cantEnIntervalo}{vels: \TLista{\float}, lim1,lim2: \float}{\float}{
    \sum\limits_{i=0}^{\longitud{vels}-1} (\IfThenElse{lim1\leq vels[i] < lim2 }{1}{0})
    }

    \aux{cantEnIntervaloCerrado}{vels: \TLista{\float}, lim1,lim2: \float}{\float}{
    \sum\limits_{i=0}^{\longitud{vels}-1} (\IfThenElse{lim1\leq vels[i] \leq lim2 }{1}{0})
    }
    
    \pagebreak
    
    \pred{esMinimo}{vels: \TLista{\float}, min: \float}{
        min \in vels \y \paraTodo{i}{\ent}{
            0 \leq i < \longitud{vels} \implicaLuego min \leq vels[i]}
    }
    
    \pred{esMaximo}{vels: \TLista{\float}, max: \float}{
        max \in vels \y \paraTodo{i}{\ent}{
            0 \leq i < \longitud{vels} \implicaLuego vels[i] \leq max}
    }
}

\end{proc}

\end{document}